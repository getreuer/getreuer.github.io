<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="author" content="Pascal Getreuer" />
  <title>Achordion: Customizing the tap-hold decision</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<link rel="stylesheet" href="../../../site.css" type="text/css" />
<link rel="icon" href="../../../favicon.ico" type="image/x-icon" />
<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC" rel="stylesheet" />
<script type="text/javascript" src="../../../site.js" ></script>
</head>
<body>
<div id="navbar">
<div id="navhold">
  <a href="../../../index.html">Home</a>
  <a href="../../../papers/index.html">Papers</a>
  <a href="../../../posts/index.html">Posts</a>
</div>
</div>
<div id="content">
<div id="header">
<h1 class="title">Achordion: Customizing the tap-hold decision</h1>
<h2 class="author">Pascal Getreuer</h2>
</div>
<div id="TOC">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#achordion">Achordion</a></li>
<li><a href="#add-achordion-to-your-keymap">Add Achordion to your keymap</a></li>
<li><a href="#customization">Customization</a>
<ul>
<li><a href="#achordion_chord">achordion_chord()</a></li>
<li><a href="#achordion_timeout">achordion_timeout()</a></li>
</ul></li>
<li><a href="#tap-hold-configuration">Tap-hold configuration</a></li>
<li><a href="#explanation">Explanation</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul>
</div>
<p><a href="../index.html">‚Üê More about keyboards</a></p>
<div style="border-radius:4px; border:solid 2.5px #e6b153; padding:0 1em 0 1em">
<p>üöß¬† <strong>Consider this ‚Äúexperimental‚Äù or ‚Äúalpha quality‚Äù software</strong> ¬†üöß</p>
<p>Achordion has been running nicely for a couple weeks on my keyboards, but tap-holds are subtle. I‚Äôd appreciate your feedback! Please <a href="https://github.com/getreuer/qmk-keymap/issues">open an issue</a> or send me a message about any problems.</p>
</div>
<h2 id="overview">Overview</h2>
<p>Most people who have tried home row mods are familiar with the struggle of accidental mod activations from typing rolls. If you are an exception, consider yourself lucky! In QMK, the standard mitigations as explained <a href="https://precondition.github.io/home-row-mods">in precondition‚Äôs guide</a> are using <code>IGNORE_MOD_TAP_INTERRUPT</code> and <code>PERMISSIVE_HOLD</code> and setting <code>TAPPING_TERM</code> reasonably (in the range 160‚Äì220 ms is typical).</p>
<p>QMK‚Äôs tap-hold implementation provides (with e.g.¬†<code>TAPPING_TERM_PER_KEY</code>) the flexibility to tune these configurations per key, with callbacks taking the tap-hold keycode as an input. But I want more than that:</p>
<ul>
<li><p>Manna Harbour‚Äôs <a href="https://github.com/manna-harbour/qmk_firmware/blob/bilateral-combinations/docs/tap_hold.md#bilateral-combinations">Bilateral Combinations</a> patches the tap-hold logic to consider the tap-hold key held only when pressed together with a key on the opposite hand.</p></li>
<li><p>ZMK‚Äôs <a href="https://zmk.dev/docs/behaviors/hold-tap#advanced-configuration">Positional Hold-Tap configuration</a> takes this idea even further: for each tap-hold key, you define a list of key positions with which that tap-hold key may be considered held.</p></li>
</ul>
<p>I want that, but in QMK, and for ease of use preferably implemented as a userspace library‚Äîshort of having something like this as a core QMK feature‚Äîinstead of a patch. This post introduces Achordion, a library that does that.</p>
<p>Just to clarify, I‚Äôm not suggesting home row mods are broken without Achordion. Consider Achordion an ‚Äúenhancement,‚Äù not a fix. I find QMK‚Äôs implementation usable and enjoyable as it is (with <code>IGNORE_MOD_TAP_INTERRUPT</code> and <code>PERMISSIVE_HOLD</code>, of course), and it‚Äôs been my daily driver for long enough to say it‚Äôs definitely practical.</p>
<h2 id="achordion">Achordion</h2>
<p><strong>Achordion</strong> is a userspace QMK library that customizes when tap-hold keys are considered held vs.¬†tapped based on the next pressed key. The library works on top of QMK‚Äôs existing tap-hold implementation. You define mod-tap and layer-tap keys as usual and use Achordion to fine-tune the behavior.</p>
<p><img src="achordion.svg" /></p>
<p>When QMK settles a tap-hold key as ‚Äúheld,‚Äù Achordion intercepts the event. Achordion then revises the event as a tap or passes it along as a hold based on the following rules:</p>
<ul>
<li><p><strong>Chord condition</strong>: On the next key press, a customizable <code>achordion_chord()</code> function is called, which takes the tap-hold key and the next key pressed as args. When the function returns true, the tap-hold key is settled as held, and otherwise as tapped.</p></li>
<li><p><strong>Timeout</strong>: If no other key press occurs within a timeout, the tap-hold key is settled as held. This is customizable per key with <code>achordion_timeout()</code>.</p></li>
</ul>
<p>Achordion only changes the behavior when QMK considers the key to be held. It changes some would-be holds to taps, but no taps to holds.</p>
<h4 id="compatibility">Compatibility</h4>
<p>When Achordion settles a tap-hold key, it plumbs the tap or hold event back into the handling pipeline, so other features including macros in <code>process_record_user()</code> will see it. So Achordion should interoperate with most QMK features and user code. I‚Äôve been using Achordion successfully together with <a href="../autocorrection/index.html">Autocorrection</a>, <a href="../caps-word/index.html">Caps Word</a>, and <a href="../custom-shift-keys/index.html">Custom Shift Keys</a>.</p>
<p>Limitations:</p>
<p>Some QMK features handle events before the point where userspace code can intercept them. I don‚Äôt expect Achordion to interoperate properly with them, and unfortunately, this isn‚Äôt entirely fixable without making changes to core QMK code. It is still possible to use these features and Achrodion in your keymap, but behavior may be poor when using these features while holding a tap-hold key. Particularly:</p>
<ul>
<li><p><a href="https://docs.qmk.fm/#/feature_key_lock">Key Lock</a> probably doesn‚Äôt work with Achordion.</p></li>
<li><p><a href="https://docs.qmk.fm/#/feature_dynamic_macros">Dynamic Macros</a> probably doesn‚Äôt work with Achordion.</p></li>
<li><p><a href="https://docs.qmk.fm/#/feature_combo">Combos</a> also handle events before Achordion. A mitigation is implemented so that combo events bypass Achordion, so combos and tap-hold keys should still work together.</p></li>
</ul>
<p>Additionally, <code>RETRO_TAP</code> and <code>RETRO_SHIFT</code> aren‚Äôt supported. It looks possible, but I haven‚Äôt yet implemented them.</p>
<h2 id="add-achordion-to-your-keymap">Add Achordion to your keymap</h2>
<p><strong>Step 1:</strong> In your <code>keymap.c</code>, call Achordion from your <code>process_record_user()</code> function:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;features/achordion.h&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="dt">bool</span> process_record_user(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="cf">if</span> (!process_achordion(keycode, record)) { <span class="cf">return</span> false; }</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="co">// Your macros ...</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="cf">return</span> true;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>If your <code>process_record_user()</code> has other handlers or macros, Achordion should preferably be called before anything else.</p>
<p><strong>Step 2:</strong> In your <code>keymap.c</code>, define (or add to) <code>matrix_scan_user()</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">void</span> matrix_scan_user(<span class="dt">void</span>) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  achordion_task();</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Step 3:</strong> In your rules.mk, add</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode mk"><code class="sourceCode makefile"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">SRC </span><span class="ch">+=</span><span class="st"> features/achordion.c</span></span></code></pre></div>
<p><strong>Step 4:</strong> In the directory containing your <code>keymap.c</code>, create a <code>features</code> subdirectory and copy <a href="https://github.com/getreuer/qmk-keymap/blob/main/features/achordion.h">achordion.h</a> and <a href="https://github.com/getreuer/qmk-keymap/blob/main/features/achordion.c">achordion.c</a> there.</p>
<p>You‚Äôll also of course want to have some tap-hold keys in your keymap. Define mod-tap and layer-tap keys in your keymap in the usual way as described in the <a href="https://docs.qmk.fm/#/mod_tap">Mod-Tap documentation</a>.</p>
<h2 id="customization">Customization</h2>
<h3 id="achordion_chord">achordion_chord()</h3>
<p>This callback is the main point of customization. Suppose that while a tap-hold key is pressed down, some other key is pressed. Then <code>achordion_chord()</code> is called to decide the outcome. It takes both the tap-hold key and other key as inputs. The return value is <code>true</code> to consider the tap-hold key held or <code>false</code> to consider it tapped.</p>
<p>The default definition of <code>achordion_chord()</code> returns true if the two keys are on opposite hands, producing an effect like Bilateral Combinations:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">bool</span> achordion_chord(<span class="dt">uint16_t</span> tap_hold_keycode,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>                         keyrecord_t* tap_hold_record,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>                         <span class="dt">uint16_t</span> other_keycode,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>                         keyrecord_t* other_record) {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="cf">return</span> achordion_opposite_hands(tap_hold_record, other_record);</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>But there is more flexibility than this. You can make any condition based on the tap-hold key‚Äôs and the other key‚Äôs keycodes or records. For instance, <a href="https://github.com/getreuer/qmk-keymap">in my keymap</a> I made a few exceptions to the opposite hands rule:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">bool</span> achordion_chord(<span class="dt">uint16_t</span> tap_hold_keycode,</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>                         keyrecord_t* tap_hold_record,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>                         <span class="dt">uint16_t</span> other_keycode,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>                         keyrecord_t* other_record) {</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  <span class="co">// Exceptionally consider the following chords as holds, even though they</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  <span class="co">// are on the same hand in Dvorak.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  <span class="cf">switch</span> (tap_hold_keycode) {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="cf">case</span> HOME_A:  <span class="co">// A + U.</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>      <span class="cf">if</span> (other_keycode == HOME_U) { <span class="cf">return</span> true; }</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>      <span class="cf">break</span>;</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="cf">case</span> HOME_S:  <span class="co">// S + H and S + G.</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>      <span class="cf">if</span> (other_keycode == HOME_H || other_keycode == KC_G) { <span class="cf">return</span> true; }</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>      <span class="cf">break</span>;</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>  }</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>  <span class="co">// Also allow same-hand holds when the other key is in the rows below the</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>  <span class="co">// alphas. I need the `% (MATRIX_ROWS / 2)` because my keyboard is split.</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>  <span class="cf">if</span> (other_record-&gt;event.key.row % (MATRIX_ROWS / <span class="dv">2</span>) &gt;= <span class="dv">4</span>) { <span class="cf">return</span> true; }</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>  <span class="co">// Otherwise, follow the opposite hands rule.</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>  <span class="cf">return</span> achordion_opposite_hands(tap_hold_record, other_record);</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>}</span></code></pre></div>
<p>With the above, my layer-tap on <code>A</code> switches layers when chorded with <code>U</code> or chorded with keys below the alphas. But with any other left-hand key, <code>A</code> is considered tapped.</p>
<h3 id="achordion_timeout">achordion_timeout()</h3>
<p>The <code>achordion_timeout()</code> callback customizes the timeout duration per each tap-hold key. By default, the timeout is 1000 ms (1 second) for all keys:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">uint16_t</span> achordion_timeout(<span class="dt">uint16_t</span> tap_hold_keycode) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="cf">return</span> <span class="dv">1000</span>;</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>The timeout duration must be in the range 0 to 32767 ms, the upper limit due to 16-bit timer limitations. A timeout of 0 bypasses Achordion, making no modification to QMK‚Äôs tap-hold decision. In my keymap, I bypass Achordion for a couple tap-hold keys, and otherwise use a timeout of 800 ms:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">uint16_t</span> achordion_timeout(<span class="dt">uint16_t</span> tap_hold_keycode) {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="cf">switch</span> (tap_hold_keycode) {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="cf">case</span> HOME_SC:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="cf">case</span> HOME_Z:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>      <span class="cf">return</span> <span class="dv">0</span>;  <span class="co">// Bypass Achordion for these keys.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  }</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  <span class="cf">return</span> <span class="dv">800</span>;  <span class="co">// Otherwise use a timeout of 800 ms.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="tap-hold-configuration">Tap-hold configuration</h2>
<p>Regardless of whether you use Achordion, you need to tune QMK‚Äôs tap-hold configuration to get a decent home row mods experience. Here are the settings I use.</p>
<p>In config.h:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">// Tap-hold configuration for home row mods.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="pp">#define TAPPING_TERM 180</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="pp">#define IGNORE_MOD_TAP_INTERRUPT</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="pp">#define PERMISSIVE_HOLD</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="pp">#define TAPPING_FORCE_HOLD_PER_KEY</span></span></code></pre></div>
<p>In keymap.c:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="dt">bool</span> get_tapping_force_hold(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="co">// If you quickly hold a tap-hold key after tapping it, the tap action is</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="co">// repeated. Key repeating is useful e.g. for Vim navigation keys, but can</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  <span class="co">// lead to missed triggers in fast typing. Here, returning true means we</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="co">// instead want to &quot;force hold&quot; and disable key repeating.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  <span class="cf">switch</span> (keycode) {</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="co">// Repeating is useful for Vim navigation keys.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    <span class="cf">case</span> HOME_U:</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="cf">case</span> HOME_H:</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    <span class="co">// Repeating Z is useful for spamming undo.</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>    <span class="cf">case</span> HOME_Z:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>      <span class="cf">return</span> false;  <span class="co">// Enable key repeating.</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>    <span class="cf">default</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>      <span class="cf">return</span> true;  <span class="co">// Otherwise, force hold and disable key repeating.</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>  }</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>See also the QMK documentation on <a href="https://docs.qmk.fm/#/tap_hold">Tap-Hold Configuration Options</a> for details on what these options mean and <a href="https://precondition.github.io/home-row-mods#tap-hold-configuration-settings">precondition‚Äôs guide</a> for their use with home row mods.</p>
<h2 id="explanation">Explanation</h2>
<p>If you are interested in the technical details, here is an explanation of Achordion‚Äôs implementation and how it works together with QMK‚Äôs core tap-hold handling.</p>
<h4 id="tap-hold-event-plumbing">Tap-hold event plumbing</h4>
<p>The life of a tap-hold key event goes like this, to my understanding:</p>
<ol type="1">
<li>When matrix scanning detects a change, an event is generated.</li>
<li><a href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/action.c#L70">void action_exec(keyevent_t event)</a> is where handling of the event begins.</li>
<li><code>action_exec()</code> in turn calls into the tap-hold handling code <a href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/action_tapping.c#L69">void action_tapping_process(keyrecord_t record)</a>. The code here is complicated, and depending on the situation, the key event might go into a waiting buffer before it is passed to further handlers.</li>
<li>Once the tap-hold handler has ‚Äúsettled‚Äù the decision of whether the key is tapped vs.¬†held, it calls <a href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/action.c#L203">void process_record(keyrecord_t* record)</a>. For a tap-hold key event, the <code>tap.count</code> field indicates the outcome of this decision: a positive value means tapped and zero means held.</li>
<li><code>process_record()</code> calls <a href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/quantum.c#L196">process_record_quantum(keyrecord_t* record)</a>, which is the main point for calling into other most other QMK features and <code>process_record_user()</code>. Fortunately for userspace libraries, <code>process_record_user()</code> is called early on before most other handlers, so Achordion is able to intercept tap-hold events before most features see it.</li>
</ol>
<h4 id="intercepting-the-event">Intercepting the event</h4>
<p>When Achordion sees a tap-hold press event, it ‚Äúintercepts‚Äù it so that subsequent handlers don‚Äôt see it immediately. This is implemented by saving the keycode and record args (so that we can use them later) and returning false (telling the caller to skip default handling).</p>
<h4 id="holding-the-key">Holding the key</h4>
<p>If we decide the key was held, we perform its hold action. The hold action information is squirreled within the upper byte of the keycode. After some bit manipulation to extract it, we can call <code>register_mods()</code> for a mod-tap or <code>layer_on()</code> for a layer-tap as appropriate.</p>
<p>But there is a complication for layer-taps: if we decided that the key was held in response to a press event on another key, then the keycode for that other key does not take into account the layer change that was just made. To get around this, we call <code>process_record()</code>, passing the same record to have it re-process the event after the layer change, then return false to block the original event.</p>
<h4 id="tapping-the-key">Tapping the key</h4>
<p>If instead we decide the key was tapped, we perform its tap action. An easy implementation would be to call <code>tap_code()</code> on the basic keycode, but then subsequent handlers would miss these taps. For instance if you are also running <a href="../autocorrection/index.html">autocorrection</a>, handling these taps would matter to detect typos correctly. To get subsequent handlers to see them, we again do some event plumbing:</p>
<ol type="1">
<li><p>Revise the tap-hold key‚Äôs record to a tap press event by changing its <code>tap.count</code> field, then pass this manipulated record to <code>process_record()</code>.</p></li>
<li><p>Wait for <code>TAP_CODE_DELAY</code> milliseconds.</p></li>
<li><p>Make the corresponding tap release event by changing the record‚Äôs <code>event.pressed</code> field to <code>false</code> and passing it again to <code>process_record()</code>.</p></li>
</ol>
<h4 id="multiple-tap-hold-keys">Multiple tap-hold keys</h4>
<p>A potentially complicated situation is what to do when the next key press is also a tap-hold key that QMK has settled as held, meaning multiple tap-hold keys pressed at once. If this happens, we settle both keys as held, bypassing Achordion. This way things like home row modifier chords work and allows Achordion to otherwise consider simply a single active tap-hold key at a time.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to <span class="citation" data-cites="jdart">@jdart</span> and <span class="citation" data-cites="filterpaper">@filterpaper</span> for feedback and help to improve Achordion.</p>
<p><a href="../index.html">‚Üê More about keyboards</a></p>
</div>

<div id="footer">
<p style="text-align:right">
<a href="https://scholar.google.com/citations?user=G8Yjd9AAAAAJ" target="_blank">Google Scholar</a>
<a href="http://www.linkedin.com/in/pascalgetreuer" target="_blank">LinkedIn</a>
</p>
</div>
</body>
</html>
