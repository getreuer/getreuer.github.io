<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="author" content="Pascal Getreuer, 2022-03-22 (updated 2025-07-24)" />
  <title>Achordion: Customizing the tap-hold decision</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<link rel="stylesheet" href="../../../site.css" type="text/css" />
<link rel="icon" href="../../../favicon.ico" type="image/x-icon" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@350&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
<script type="text/javascript" src="../../../site.js" ></script>
</head>
<body>
<div id="navbar">
<div id="navhold">
  <a href="../../../index.html">Home</a>
  <a href="../../../papers/index.html">Papers</a>
  <a href="../../../posts/index.html">Posts</a>
</div>
</div>
<div id="content">
<div id="header">
<h1 class="title">Achordion: Customizing the tap-hold decision</h1>
<h2 class="author">Pascal Getreuer, 2022-03-22 (updated 2025-07-24)</h2>
</div>
<div id="TOC">
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#relationship-between-achordion-and-chordal-hold"
id="toc-relationship-between-achordion-and-chordal-hold">Relationship
between Achordion and Chordal Hold</a></li>
<li><a href="#achordion" id="toc-achordion">Achordion</a></li>
<li><a href="#add-achordion-to-your-keymap"
id="toc-add-achordion-to-your-keymap">Add Achordion to your keymap</a>
<ul>
<li><a href="#non-module-installation-historical"
id="toc-non-module-installation-historical">Non-module installation
(historical)</a></li>
</ul></li>
<li><a href="#how-does-achordion-affect-delay"
id="toc-how-does-achordion-affect-delay">How does Achordion affect
delay?</a></li>
<li><a href="#customization" id="toc-customization">Customization</a>
<ul>
<li><a href="#achordion_chord"
id="toc-achordion_chord">achordion_chord()</a></li>
<li><a href="#achordion_timeout"
id="toc-achordion_timeout">achordion_timeout()</a></li>
<li><a href="#achordion_eager_mod"
id="toc-achordion_eager_mod">achordion_eager_mod()</a></li>
<li><a href="#typing-streaks" id="toc-typing-streaks">Typing
streaks</a></li>
</ul></li>
<li><a href="#tap-hold-configuration"
id="toc-tap-hold-configuration">Tap-hold configuration</a></li>
<li><a href="#other-tricks" id="toc-other-tricks">Other tricks</a>
<ul>
<li><a href="#one-shot-mod-tap-key"
id="toc-one-shot-mod-tap-key">One-shot mod-tap key</a></li>
<li><a href="#tap-vs.-long-press" id="toc-tap-vs.-long-press">Tap
vs.¬†long press</a></li>
</ul></li>
<li><a href="#explanation" id="toc-explanation">Explanation</a></li>
<li><a href="#acknowledgements"
id="toc-acknowledgements">Acknowledgements</a></li>
</ul>
</div>
<p><a href="../index.html">‚Üê More about keyboards</a></p>
<div class="callout">
<div class="callout-header">
<p>
üöÄ¬†¬†Launched
</p>
</div>
<p><strong>Achordion-like behavior is now built into QMK with Chordal
Hold!</strong> Chordal Hold supersedes Achordion and was released in QMK
on 2025-02-27. <a
href="https://docs.qmk.fm/newbs_git_using_your_master_branch#updating-your-master-branch">Update
your QMK set up</a> and see <a
href="https://docs.qmk.fm/tap_hold#chordal-hold">Chordal Hold</a>.</p>
</div>
<div class="callout">
<div class="callout-header">
<p>
üöÄ¬†¬†Launched
</p>
</div>
<p><strong>Chordal Hold is available for ZSA keyboards in Oryx!</strong>
Find it under Oryx‚Äôs Advanced Configuration Settings (<a
href="https://blog.zsa.io/chordal-hold/">announcement</a>).</p>
</div>
<div class="callout">
<div class="callout-header">
<p>
üöÄ¬†¬†Launched
</p>
</div>
<p><strong>Chordal Hold is in <a
href="https://get.vial.today/changelog/release-0.7.4.html">Vial
0.7.4</a>!</strong> Enable it under the <em>Tap-Hold</em> tab under QMK
Settings.</p>
</div>
<h2 id="overview">Overview</h2>
<p>Most people who have tried <a
href="../glossary/index.html#home-row-mods-hrms">home row mods</a> are
familiar with the struggle of accidental mod activations from typing
rolls. If you are an exception, consider yourself lucky! In QMK, the
standard mitigations as explained <a
href="https://precondition.github.io/home-row-mods">in precondition‚Äôs
guide</a> are using <code>PERMISSIVE_HOLD</code> and setting
<code>TAPPING_TERM</code> reasonably (in the range 160‚Äì220 ms is
typical).</p>
<p>QMK‚Äôs tap-hold implementation provides (with
e.g.¬†<code>TAPPING_TERM_PER_KEY</code>) the flexibility to tune these
configurations per key, with callbacks taking the tap-hold keycode as an
input. But I want more than that:</p>
<ul>
<li><p>Manna Harbour‚Äôs <a
href="https://github.com/manna-harbour/qmk_firmware/blob/bilateral-combinations/docs/tap_hold.md#bilateral-combinations">Bilateral
Combinations</a> patches QMK‚Äôs core tap-hold logic to consider the key
held only when pressed together with a key on the opposite
hand.</p></li>
<li><p>ZMK‚Äôs <a
href="https://zmk.dev/docs/behaviors/hold-tap#advanced-configuration">Positional
Hold-Tap configuration</a> takes this idea even further: for each
tap-hold key, define a list of key positions with which that tap-hold
key may be held.</p></li>
</ul>
<p>This post introduces Achordion, a library that does that. Achordion
has evolved into core QMK feature <a
href="https://docs.qmk.fm/tap_hold#chordal-hold">Chordal Hold</a>.</p>
<h2 id="relationship-between-achordion-and-chordal-hold">Relationship
between Achordion and Chordal Hold</h2>
<p><strong>Chordal Hold is an improved version of Achordion that is
built into QMK core.</strong> Both Achordion and Chordal Hold are
finely-configurable implementations of an ‚Äúopposite hands‚Äù rule to
mitigate accidental mod triggers when using home row mods.</p>
<p>Chordal Hold is a rewrite of Achordion, and built into QMK as a core
feature. Chordal Hold is better, stronger, faster in most ways.</p>
<p>Improvements:</p>
<ul>
<li>Chordal Hold acts directly in QMK‚Äôs core tap-hold logic, eliminating
a stage of event buffering. This reduces input lag and improves interop
with other features.</li>
<li>Improved logic for multiple active tap-hold keys for better streak
handling.</li>
<li>Easier to install (just add ‚Äú<code>#define CHORDAL_HOLD</code>‚Äù in
config.h) and easier to configure with an intuitive handedness
configuration.</li>
</ul>
<p>Limitations:</p>
<ul>
<li>Chordal Hold does not have behavior analogous to Achordion‚Äôs ‚Äúeager‚Äù
mods. Fortunately with the reduced input lag, the need for eagerness is
less of an issue.</li>
</ul>
<p><strong>For former Achordion users</strong>, here is how to migrate
to Chordal Hold:</p>
<ul>
<li><p>In config.h:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TAPPING_TERM </span><span class="dv">250</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHORDAL_HOLD</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define PERMISSIVE_HOLD</span></span></code></pre></div>
<p><code>TAPPING_TERM</code> should be set relatively high, to say
250¬†ms. The Achordion timeout is effectively combined with the tapping
term under Chordal Hold, since there is just one level of event
buffering, so you want a longer tapping term.</p></li>
<li><p>If needed, define <code>chordal_hold_layout</code> to specify the
handedness of each key. Or mark a key with <code>'*'</code> to exempt it
from the ‚Äúopposite hands‚Äù rule.</p></li>
<li><p>In place of <code>achordion_chord()</code>, use the similar
<code>get_chordal_hold()</code> callback.</p></li>
</ul>
<p>See <a href="https://docs.qmk.fm/tap_hold#chordal-hold">QMK‚Äôs Chordal
Hold documentation</a> for more information. The remainder of this page
describes Achordion.</p>
<h2 id="achordion">Achordion</h2>
<p><strong>Achordion</strong> is a userspace QMK library that customizes
when tap-hold keys are considered held vs.¬†tapped based on the next
pressed key. The library works on top of QMK‚Äôs existing tap-hold
implementation. You define mod-tap and layer-tap keys as usual and use
Achordion to fine-tune the behavior.</p>
<p><img src="achordion.svg" /></p>
<p>When QMK settles a tap-hold key as ‚Äúheld,‚Äù Achordion intercepts the
event. Achordion then revises the event as a tap or passes it along as a
hold based on the following rules:</p>
<ul>
<li><p><strong>Chord condition</strong>: On the next key press, a
customizable <code>achordion_chord()</code> function is called, which
takes the tap-hold key and the next key pressed as args. When the
function returns true, the tap-hold key is settled as held, and
otherwise as tapped.</p></li>
<li><p><strong>Timeout</strong>: If no other key press occurs within a
timeout, the tap-hold key is settled as held. This is customizable per
key with <code>achordion_timeout()</code>.</p></li>
</ul>
<p>Achordion only changes the behavior when QMK considers the key to be
held. It changes some would-be holds to taps, but no taps to holds.</p>
<h4 id="compatibility">Compatibility</h4>
<p>When Achordion settles a tap-hold key, it plumbs the tap or hold
event back into the handling pipeline, so other features including
macros in <code>process_record_user()</code> will see it. So Achordion
should interoperate with most QMK features and user code. I‚Äôve been
using Achordion successfully together with <a
href="../autocorrection/index.html">Autocorrection</a>, <a
href="../caps-word/index.html">Caps Word</a>, and <a
href="../custom-shift-keys/index.html">Custom Shift Keys</a>.</p>
<p><strong>Limitations:</strong> Some QMK features handle events before
the point where userspace code can intercept them. I don‚Äôt expect
Achordion to interoperate properly with them, and unfortunately, this
isn‚Äôt entirely fixable without making changes to core QMK code. It is
still possible to use these features and Achrodion in your keymap, but
behavior may be poor when using these features while holding a tap-hold
key. Particularly:</p>
<ul>
<li><p><a href="https://docs.qmk.fm/features/key_lock">Key Lock</a>
probably doesn‚Äôt work with Achordion.</p></li>
<li><p><a href="https://docs.qmk.fm/features/dynamic_macros">Dynamic
Macros</a> probably doesn‚Äôt work with Achordion.</p></li>
<li><p><a href="https://docs.qmk.fm/features/combo">Combos</a> also
handle events before Achordion. A mitigation is implemented so that
combo events bypass Achordion, so combos and tap-hold keys should still
work together.</p></li>
</ul>
<h2 id="add-achordion-to-your-keymap">Add Achordion to your keymap</h2>
<p>Install my <a href="../qmk-community-modules/index.html">community
modules</a>. Then enable module <a
href="https://github.com/getreuer/qmk-modules/tree/main/achordion">getreuer/achordion</a>
in your <code>keymap.json</code> file. Or if <code>keymap.json</code>
does not exist, create it with the following content:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;modules&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;getreuer/achordion&quot;</span><span class="ot">]</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>That‚Äôs it.</p>
<p>You‚Äôll also of course want to have some tap-hold keys in your keymap.
Define mod-tap and layer-tap keys in your keymap in the usual way as
described in the <a href="https://docs.qmk.fm/mod_tap">Mod-Tap
documentation</a>.</p>
<p>Beyond Achordion, you can find further tips for home row mods in <a
href="../faqs/index.html#home-row-mods-are-hard-to-use">Home row mods
are hard to use</a>.</p>
<h3 id="non-module-installation-historical">Non-module installation
(historical)</h3>
<div class="callout" style="border-left-color: #e49f34">
<div class="callout-header" style="background-color: #fdebd5">
<p>
‚ö†¬†¬†Important
</p>
</div>
<p>There are two implementations of this feature: the community module
described above (recommended) and the earlier non-module implementation
described in this section. Pick one. <strong>Do not install
both</strong>, or they will conflict and fail to build.</p>
</div>
<p><strong>Step 1:</strong> In your <code>keymap.c</code>, call
Achordion from your <code>process_record_user()</code> function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;features/achordion.h&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> process_record_user<span class="op">(</span><span class="dt">uint16_t</span> keycode<span class="op">,</span> keyrecord_t<span class="op">*</span> record<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>process_achordion<span class="op">(</span>keycode<span class="op">,</span> record<span class="op">))</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Your macros ...</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If your <code>process_record_user()</code> has other handlers or
macros, Achordion should preferably be called before anything else.</p>
<p><strong>Step 2:</strong> In your <code>keymap.c</code>, define (or
add to) <code>housekeeping_task_user()</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> housekeeping_task_user<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  achordion_task<span class="op">();</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Step 3:</strong> In your rules.mk, add</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode mk"><code class="sourceCode makefile"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">SRC</span> <span class="ch">+=</span><span class="st"> features/achordion.c</span></span></code></pre></div>
<p><strong>Step 4:</strong> In the directory containing your
<code>keymap.c</code>, create a <code>features</code> subdirectory and
copy <a
href="https://raw.githubusercontent.com/getreuer/qmk-keymap/main/features/achordion.h">achordion.h</a>
and <a
href="https://raw.githubusercontent.com/getreuer/qmk-keymap/main/features/achordion.c">achordion.c</a>
there.</p>
<p><strong>Troubleshooting:</strong> Achordion makes use of some fairly
recent QMK APIs. If your keymap fails to build, a likely reason is that
your QMK installation simply needs to be updated. Particularly, building
with an outdated QMK version should fail with</p>
<pre><code>achordion: QMK version is too old to build. Please update QMK.</code></pre>
<p>If you have the qmk_firmware git repo cloned locally, do a
<code>git pull</code>. Or see <a
href="https://docs.qmk.fm/newbs_git_using_your_master_branch#updating-your-master-branch">Updating
your master branch</a> for more details.</p>
<h2 id="how-does-achordion-affect-delay">How does Achordion affect
delay?</h2>
<p>Delay is an important drawback of tap-hold keys, so here we cover how
Achordion affects that. In practice, I see no added delay with Achordion
beyond the delay that QMK‚Äôs tap-hold keys have on their own. To back
this up, I‚Äôll walk through a few cases of pressing tap-hold keys along
with other keys.</p>
<ul>
<li><p>Achordion adds no delay when QMK decided the tap-hold key was
tapped. Only holds are affected.</p></li>
<li><p><strong>Good case: normal typing.</strong> Achordion adds no
visible delay during normal typing.</p>
<ul>
<li><p>Suppose <code>PERMISSIVE_HOLD</code> is enabled (I recommend
it!), and a key is pressed and released within the tapping term while a
tap-hold key is down. Then, QMK settles the tap-hold as held the instant
the other key is released. In this good case, Achordion will receive an
event for the tap-hold key being pressed followed back-to-back by an
event for the other key being pressed, and without delay, Achordion
decides whether the mod-tap is tapped or held.</p></li>
<li><p>Alternatively if a tap-hold key is held past the tapping term,
then QMK considers the tap-hold key held, but this has no visible effect
until a following key is pressed (at least usually, holding a mod or
layer switch by itself has no visible effect). Once that following key
press happens, Achordion can settle its decision whether the key is
tapped vs.¬†held. So again no visible delay is added.</p></li>
</ul></li>
<li><p><strong>Tricky case: mod + mouse.</strong> A tricky case for
mod-taps and especially with Achordion or Bilateral Combinations is
using a mod-tap with a mouse, for instance to do Ctrl + click. Since
there is no following key press after the mod-tap goes down, you would
normally need to wait out Achordion‚Äôs timeout before clicking the mouse.
This case was a big gripe for me, so I came up with an ‚Äúeager mods‚Äù
workaround to eliminate this delay. This is <a
href="#achordion_eager_mod">described further below</a>.</p></li>
</ul>
<h2 id="customization">Customization</h2>
<h3 id="achordion_chord">achordion_chord()</h3>
<p>This callback is the main point of customization. Suppose that while
a tap-hold key is pressed down, some other key is pressed. Then
<code>achordion_chord()</code> is called to decide the outcome. It takes
both the tap-hold key and other key as inputs. The return value is
<code>true</code> to consider the tap-hold key held or
<code>false</code> to consider it tapped.</p>
<p>The default definition of <code>achordion_chord()</code> returns true
if the two keys are on opposite hands, producing an effect like
Bilateral Combinations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> achordion_chord<span class="op">(</span><span class="dt">uint16_t</span> tap_hold_keycode<span class="op">,</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                     keyrecord_t<span class="op">*</span> tap_hold_record<span class="op">,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">uint16_t</span> other_keycode<span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                     keyrecord_t<span class="op">*</span> other_record<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> achordion_opposite_hands<span class="op">(</span>tap_hold_record<span class="op">,</span> other_record<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But there is more flexibility than this. You can make any condition
based on the tap-hold key‚Äôs and the other key‚Äôs keycodes or records. For
instance, <a href="https://github.com/getreuer/qmk-keymap">in my
keymap</a> I made a few exceptions to the opposite hands rule:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> achordion_chord<span class="op">(</span><span class="dt">uint16_t</span> tap_hold_keycode<span class="op">,</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                     keyrecord_t<span class="op">*</span> tap_hold_record<span class="op">,</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">uint16_t</span> other_keycode<span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                     keyrecord_t<span class="op">*</span> other_record<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Exceptionally consider the following chords as holds, even though they</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// are on the same hand in Dvorak.</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>tap_hold_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> HOME_A<span class="op">:</span>  <span class="co">// A + U.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>other_keycode <span class="op">==</span> HOME_U<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> HOME_S<span class="op">:</span>  <span class="co">// S + H and S + G.</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>other_keycode <span class="op">==</span> HOME_H <span class="op">||</span> other_keycode <span class="op">==</span> KC_G<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Also allow same-hand holds when the other key is in the rows below the</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// alphas. I need the `% (MATRIX_ROWS / 2)` because my keyboard is split.</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>other_record<span class="op">-&gt;</span>event<span class="op">.</span>key<span class="op">.</span>row <span class="op">%</span> <span class="op">(</span>MATRIX_ROWS <span class="op">/</span> <span class="dv">2</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="dv">4</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Otherwise, follow the opposite hands rule.</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> achordion_opposite_hands<span class="op">(</span>tap_hold_record<span class="op">,</span> other_record<span class="op">);</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With the above, my layer-tap on <code>A</code> switches layers when
chorded with <code>U</code> or chorded with keys below the alphas. But
with any other left-hand key, <code>A</code> is considered tapped.</p>
<p><strong>Matrix coordinates:</strong> It makes sense to treat the
thumb clusters and outermost rows or columns differently than the main
alphas area, depending on the geometry of your keyboard. You can use
<code>other_record-&gt;event.key.row</code> and <code>.col</code> to get
the matrix coordinate of the other key. A complication is that on split
keyboards, rows are typically doubled up so that the first
<code>MATRIX_ROWS / 2</code> rows are the left hand and the following
<code>MATRIX_ROWS / 2</code> rows are the right hand. On my 6x6 split
Dactyl Ergodox, <code>.row =</code> 4 or 10 corresponds to the keys just
below the alphas and 5 and 11 to the thumb clusters. I exclude them from
the opposite hands rule with:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>other_record<span class="op">-&gt;</span>event<span class="op">.</span>key<span class="op">.</span>row <span class="op">%</span> <span class="op">(</span>MATRIX_ROWS <span class="op">/</span> <span class="dv">2</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="dv">4</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>See <a
href="../developing-qmk-features/index.html#corresponding-physical-keys-to-matrix-positions">corresponding
physical keys to matrix positions</a> for further tips on working out
the matrix correspondence for your keyboard.</p>
<p>It is also perfectly valid to make conditions on
<code>other_keycode</code>. For instance if you only want the opposite
hands rule on alpha keys, do</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>other_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> QK_MOD_TAP <span class="op">...</span> QK_MOD_TAP_MAX<span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> QK_LAYER_TAP <span class="op">...</span> QK_LAYER_TAP_MAX<span class="op">:</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    other_keycode <span class="op">&amp;=</span> <span class="bn">0xff</span><span class="op">;</span>  <span class="co">// Get base keycode.</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Allow same-hand holds with non-alpha keys.</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>other_keycode <span class="op">&gt;</span> KC_Z<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> achordion_opposite_hands<span class="op">(</span>tap_hold_record<span class="op">,</span> other_record<span class="op">);</span></span></code></pre></div>
<h3 id="achordion_timeout">achordion_timeout()</h3>
<p>The <code>achordion_timeout()</code> callback customizes the timeout
duration per each tap-hold key. By default, the timeout is 1000 ms (1
second) for all keys:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint16_t</span> achordion_timeout<span class="op">(</span><span class="dt">uint16_t</span> tap_hold_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1000</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The timeout duration must be in the range 0 to 32767 ms, the upper
limit due to 16-bit timer limitations. I suggest setting it between 500
and 5000 ms.</p>
<p>Achordion can only change the tap-hold decision during the timeout
window. If the timeout is too short, Achordion has little effect. A
timeout of 0 bypasses Achordion, making no modification to QMK‚Äôs
tap-hold decision. In my keymap, I bypass Achordion for a couple
tap-hold keys, and otherwise use a timeout of 800 ms:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint16_t</span> achordion_timeout<span class="op">(</span><span class="dt">uint16_t</span> tap_hold_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>tap_hold_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> HOME_SC<span class="op">:</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> HOME_Z<span class="op">:</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Bypass Achordion for these keys.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">800</span><span class="op">;</span>  <span class="co">// Otherwise use a timeout of 800 ms.</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="achordion_eager_mod">achordion_eager_mod()</h3>
<p>Mod-tap keys have the drawback that they add a delay between pressing
the button and keys being sent to the host. This is especially sluggish
when using mod-taps with a mouse: Ctrl + Click requires holding the
mod-tap, waiting out Achordion‚Äôs timeout, then clicking.</p>
<p>There are some partial solutions:</p>
<ul>
<li><p>Of course, reducing Achordion‚Äôs timeout reduces this delay,
though as mentioned above, Achordion has little effect if the timeout is
too short.</p></li>
<li><p>Another workaround is to use <a
href="https://docs.qmk.fm/features/mouse_keys">mouse keys</a> while
holding a mod-tap, which will handle like any other key event to settle
the mod-tap as held, but this doesn‚Äôt work with an external
mouse.</p></li>
</ul>
<p>A better solution without these compromises is to ‚Äúeagerly‚Äù apply the
mod while the tap-hold decision is still being settled. When QMK sends
Achordion a mod-tap hold event, the mod is immediately applied. If later
the mod-tap is settled as a tap, the mod is canceled before any
following key press takes effect.</p>
<p>The <code>achordion_eager_mod()</code> callback defines which mods
are eager. The <code>mod</code> arg should be compared with
<code>MOD_</code> prefixed codes, not <code>KC_</code> codes. The
default callback makes Shift and Ctrl mods eager:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> achordion_eager_mod<span class="op">(</span><span class="dt">uint8_t</span> mod<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>mod<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> MOD_LSFT<span class="op">:</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> MOD_RSFT<span class="op">:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> MOD_LCTL<span class="op">:</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> MOD_RCTL<span class="op">:</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// Eagerly apply Shift and Ctrl mods.</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This makes Achordion much nicer to use with a mouse!</p>
<p><strong>Notes:</strong></p>
<ul>
<li><p>Even with eager mods, the initial hold event from QMK is still
delayed by the tapping term. You can reduce <code>TAPPING_TERM</code>,
or use <code>TAPPING_TERM_PER_KEY</code> for a specific key, to reduce
delay further.</p></li>
<li><p>On an eager mod <code>MT</code> key, hold events are not plumbed
to subsequent handlers, even once settled. Tap events are
plumbed.</p></li>
</ul>
<h3 id="typing-streaks">Typing streaks</h3>
<p>The <code>ACHORDION_STREAK</code> option disables hold behaviors when
in a typing streak. In a sequence of typing keys <kbd>A</kbd>,
<kbd>B</kbd>, <kbd>C</kbd> where <code>B</code> is a tap-hold key and
<code>A</code> and <code>C</code> are regular keys, a ‚Äústreak‚Äù is
determined as the duration from the release of <code>A</code> until the
press of <code>C</code> being quicker than a timeout, by default 200 ms.
This can help prevent accidental mod activation during fast tapping
sequences. It is inspired by <a
href="https://sunaku.github.io/home-row-mods.html#typing-streaks">sunaku‚Äôs
typing streak logic</a>.</p>
<p>To enable typing streak detection, add in config.h:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ACHORDION_STREAK</span></span></code></pre></div>
<p>Optionally, define <code>achordion_streak_chord_timeout()</code> in
keymap.c to customize the typing streak timeout:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint16_t</span> achordion_streak_chord_timeout<span class="op">(</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint16_t</span> tap_hold_keycode<span class="op">,</span> <span class="dt">uint16_t</span> next_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">200</span><span class="op">;</span>  <span class="co">// Default of 100 ms.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A different streak timeout may be defined per key if desired. A
timeout of zero disables streak detection for that key. For instance the
following sets a shorter streak timeout for Shift and disables streak
detection for layer-tap keys:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint16_t</span> achordion_streak_chord_timeout<span class="op">(</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint16_t</span> tap_hold_keycode<span class="op">,</span> <span class="dt">uint16_t</span> next_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>IS_QK_LAYER_TAP<span class="op">(</span>tap_hold_keycode<span class="op">))</span> <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Disable streak detection on layer-tap keys.</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Otherwise, tap_hold_keycode is a mod-tap key.</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint8_t</span> mod <span class="op">=</span> mod_config<span class="op">(</span>QK_MOD_TAP_GET_MODS<span class="op">(</span>tap_hold_keycode<span class="op">));</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">((</span>mod <span class="op">&amp;</span> MOD_LSFT<span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">100</span><span class="op">;</span>  <span class="co">// A shorter streak timeout for Shift mod-tap keys.</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">240</span><span class="op">;</span>  <span class="co">// A longer timeout otherwise.</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Optionally, define <code>achordion_streak_continue()</code> in
keymap.c to customize which keys can be part of a streak. The default
definition is the following, allowing letters A‚ÄìZ, punctuations
<code>.,'</code> and space to continue streaks:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> achordion_streak_continue<span class="op">(</span><span class="dt">uint16_t</span> keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If mods other than shift or AltGr are held, don&#39;t continue the streak.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>get_mods<span class="op">()</span> <span class="op">&amp;</span> <span class="op">(</span>MOD_MASK_CG <span class="op">|</span> MOD_BIT_LALT<span class="op">))</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This function doesn&#39;t get called for holds, so convert to tap keycodes.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>IS_QK_MOD_TAP<span class="op">(</span>keycode<span class="op">))</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    keycode <span class="op">=</span> QK_MOD_TAP_GET_TAP_KEYCODE<span class="op">(</span>keycode<span class="op">);</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>IS_QK_LAYER_TAP<span class="op">(</span>keycode<span class="op">))</span> <span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    keycode <span class="op">=</span> QK_LAYER_TAP_GET_TAP_KEYCODE<span class="op">(</span>keycode<span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Regular letters and punctuation continue the streak.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>keycode <span class="op">&gt;=</span> KC_A <span class="op">&amp;&amp;</span> keycode <span class="op">&lt;=</span> KC_Z<span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> KC_DOT<span class="op">:</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> KC_COMMA<span class="op">:</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> KC_QUOTE<span class="op">:</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> KC_SPACE<span class="op">:</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// All other keys end the streak.</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="tap-hold-configuration">Tap-hold configuration</h2>
<p>Regardless of whether you use Achordion, you need to tune QMK‚Äôs
tap-hold configuration to get a decent home row mods experience. Here
are the settings I use.</p>
<p>In config.h:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Tap-hold configuration for home row mods.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TAPPING_TERM </span><span class="dv">175</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define PERMISSIVE_HOLD</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define QUICK_TAP_TERM_PER_KEY</span></span></code></pre></div>
<p>In keymap.c:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint16_t</span> get_quick_tap_term<span class="op">(</span><span class="dt">uint16_t</span> keycode<span class="op">,</span> keyrecord_t<span class="op">*</span> record<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If you quickly hold a tap-hold key after tapping it, the tap action is</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// repeated. Key repeating is useful e.g. for Vim navigation keys, but can</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// lead to missed triggers in fast typing. Here, returning 0 means we</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// instead want to &quot;force hold&quot; and disable key repeating.</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> HOME_N<span class="op">:</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Repeating is useful for Vim navigation keys.</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> QHOME_J<span class="op">:</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> QHOME_K<span class="op">:</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> QHOME_L<span class="op">:</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> QUICK_TAP_TERM<span class="op">;</span>  <span class="co">// Enable key repeating.</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Otherwise, force hold and disable key repeating.</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>See also the QMK documentation on <a
href="https://docs.qmk.fm/tap_hold">Tap-Hold Configuration Options</a>
for details on what these options mean and <a
href="https://precondition.github.io/home-row-mods#tap-hold-configuration-settings">precondition‚Äôs
guide</a> for their use with home row mods.</p>
<h2 id="other-tricks">Other tricks</h2>
<p>Here are a couple further tricks for getting the most out of tap-hold
keys. They work with Achordion, but Achordion is not required.</p>
<h3 id="one-shot-mod-tap-key">One-shot mod-tap key</h3>
<p>You can modify a mod-tap key to behave like a one-shot mod when held.
This changes the hold action so that the mod applies to only the first
key tapped while the mod-tap is held. Thanks to <span class="citation"
data-cites="rafaelromao">@rafaelromao</span> for this idea. This can be
done by adding in keymap.c:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Copyright 2022 Google LLC.</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="an">SPDX-License-Identifier:</span><span class="co"> Apache-2.0</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Replaces a mod-tap key&#39;s hold function with its one-shot counterpart.</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">bool</span> oneshot_mod_tap<span class="op">(</span><span class="dt">uint16_t</span> keycode<span class="op">,</span> keyrecord_t<span class="op">*</span> record<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>record<span class="op">-&gt;</span>tap<span class="op">.</span>count <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// Key is being held.</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>record<span class="op">-&gt;</span>event<span class="op">.</span>pressed<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">const</span> <span class="dt">uint8_t</span> mods <span class="op">=</span> <span class="op">(</span>keycode <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">&amp;</span> <span class="bn">0x1f</span><span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>      add_oneshot_mods<span class="op">(((</span>mods <span class="op">&amp;</span> <span class="bn">0x10</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> mods <span class="op">:</span> <span class="op">(</span>mods <span class="op">&lt;&lt;</span> <span class="dv">4</span><span class="op">));</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// Skip default handling.</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// Continue default handling.</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> process_record_user<span class="op">(</span><span class="dt">uint16_t</span> keycode<span class="op">,</span> keyrecord_t<span class="op">*</span> record<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>process_achordion<span class="op">(</span>keycode<span class="op">,</span> record<span class="op">))</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> LSFT_T<span class="op">(</span>KC_D<span class="op">):</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> RSFT_T<span class="op">(</span>KC_K<span class="op">):</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> oneshot_mod_tap<span class="op">(</span>keycode<span class="op">,</span> record<span class="op">);</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="tap-vs.-long-press">Tap vs.¬†long press</h3>
<p>You can have a key perform a different action on tap vs.¬†when held a
bit longer by customizing a layer-tap <code>LT</code> key. Thanks to
<span class="citation" data-cites="filterpaper">@filterpaper</span> and
<span class="citation" data-cites="jweickm">@jweickm</span> for teaching
me this trick. First, define a layer-tap key like
<code>LT(0, kc)</code>, where <code>kc</code> is a basic keycode to be
sent on tap and the layer is a dummy placeholder.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define COMM_COPY </span>LT<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="pp"> KC_COMM</span><span class="op">)</span></span></code></pre></div>
<p>Then in <code>process_record_user()</code>, we customize the long
press action:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Helper for implementing tap vs. long-press keys. Given a tap-hold</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">// key event, replaces the hold function with `long_press_keycode`.</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">bool</span> process_tap_or_long_press_key<span class="op">(</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    keyrecord_t<span class="op">*</span> record<span class="op">,</span> <span class="dt">uint16_t</span> long_press_keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>record<span class="op">-&gt;</span>tap<span class="op">.</span>count <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// Key is being held.</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>record<span class="op">-&gt;</span>event<span class="op">.</span>pressed<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>      tap_code16<span class="op">(</span>long_press_keycode<span class="op">);</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// Skip default handling.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// Continue default handling.</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> process_record_user<span class="op">(</span><span class="dt">uint16_t</span> keycode<span class="op">,</span> keyrecord_t<span class="op">*</span> record<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>process_achordion<span class="op">(</span>keycode<span class="op">,</span> record<span class="op">))</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>keycode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> COMM_COPY<span class="op">:</span>  <span class="co">// Comma on tap, Ctrl+C on long press.</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> process_tap_or_long_press_key<span class="op">(</span>record<span class="op">,</span> C<span class="op">(</span>KC_C<span class="op">));</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Other macros...</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>See <a href="../triggers/index.html#tap-vs.-long-press">tap vs.¬†long
press</a> for further discussion and variations on this idea.</p>
<h2 id="explanation">Explanation</h2>
<p>If you are interested in the technical details, here is an
explanation of Achordion‚Äôs implementation and how it works together with
QMK‚Äôs core tap-hold handling.</p>
<h4 id="tap-hold-event-plumbing">Tap-hold event plumbing</h4>
<p>The life of a tap-hold key event goes like this, to my
understanding:</p>
<ol type="1">
<li>When matrix scanning detects a change, an event is generated.</li>
<li><a
href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/action.c#L70">void
action_exec(keyevent_t event)</a> is where handling of the event
begins.</li>
<li><code>action_exec()</code> in turn calls into the tap-hold handling
code <a
href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/action_tapping.c#L69">void
action_tapping_process(keyrecord_t record)</a>. The code here is
complicated, and depending on the situation, the key event might go into
a waiting buffer before it is passed to further handlers.</li>
<li>Once the tap-hold handler has ‚Äúsettled‚Äù the decision of whether the
key is tapped vs.¬†held, it calls <a
href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/action.c#L203">void
process_record(keyrecord_t* record)</a>. For a tap-hold key event, the
<code>tap.count</code> field indicates the outcome of this decision: a
positive value means tapped and zero means held.</li>
<li><code>process_record()</code> calls <a
href="https://github.com/qmk/qmk_firmware/blob/d9393b86842b7ef143259b5f771ae7969f98cbb4/quantum/quantum.c#L196">process_record_quantum()</a>,
which is the main point for calling into other most other QMK features
and <code>process_record_user()</code>. Fortunately for userspace
libraries, <code>process_record_user()</code> is called early on before
most other handlers, so Achordion is able to intercept tap-hold events
before most features see it.</li>
</ol>
<h4 id="intercepting-the-event">Intercepting the event</h4>
<p>When Achordion sees a tap-hold press event, it ‚Äúintercepts‚Äù it so
that subsequent handlers don‚Äôt see it immediately. This is implemented
by saving the keycode and record args (so that we can use them later)
and returning false (telling the caller to skip default handling).</p>
<h4 id="holding-the-key">Holding the key</h4>
<p>If we decide the key was held, we perform its hold action. One
possible approach would be to extract the mod or layer from the upper
byte of the keycode, then call <code>register_mods()</code> for a
mod-tap or <code>layer_on()</code> for a layer-tap as appropriate.
However, this would prevent subsequent handlers from responding to the
hold event. Instead, we call <code>process_record()</code>, passing the
record that Achordion had received earlier from QMK.</p>
<p>There is further a complication for layer-taps: if we decided that
the key was held in response to a press event on another key, then the
keycode for that other key does not take into account the layer change
that was just made. To get around this, we call
<code>process_record()</code>, passing the same record to have it
re-process the event after the layer change, then return false to block
the original event.</p>
<h4 id="tapping-the-key">Tapping the key</h4>
<p>If instead we decide the key was tapped, we perform its tap action.
An easy implementation would be to call <code>tap_code()</code> on the
basic keycode, but again, subsequent handlers then would miss these
taps. For instance if you are also running <a
href="../autocorrection/index.html">autocorrection</a>, handling these
taps would matter to detect typos correctly. To get subsequent handlers
to see them, we again do some event plumbing:</p>
<ol type="1">
<li><p>Revise the tap-hold key‚Äôs record to a tap press event by changing
its <code>tap.count</code> field, then pass this manipulated record to
<code>process_record()</code>.</p></li>
<li><p>Wait for <code>TAP_CODE_DELAY</code> milliseconds.</p></li>
<li><p>Make the corresponding tap release event by changing the record‚Äôs
<code>event.pressed</code> field to <code>false</code> and passing it
again to <code>process_record()</code>.</p></li>
</ol>
<h4 id="multiple-tap-hold-keys">Multiple tap-hold keys</h4>
<p>A potentially complicated situation is what to do when the next key
press is also a tap-hold key that QMK has settled as held, meaning
multiple tap-hold keys pressed at once. If this happens, we settle both
keys as held, bypassing Achordion. This way things like home row
modifier chords work and allows Achordion to otherwise consider simply a
single active tap-hold key at a time.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Much thanks to GitHub users <span class="citation"
data-cites="akaralar">@akaralar</span>, <span class="citation"
data-cites="alxzh">@alxzh</span>, <span class="citation"
data-cites="bschwehn">@bschwehn</span>, <span class="citation"
data-cites="Ceffa93">@Ceffa93</span>, <span class="citation"
data-cites="christoph-cullmann">@christoph-cullmann</span>, <span
class="citation" data-cites="drashna">@drashna</span>, <span
class="citation" data-cites="fdidron">@fdidron</span>, <span
class="citation" data-cites="filterpaper">@filterpaper</span>, <span
class="citation" data-cites="gazpachoking">@gazpachoking</span>, <span
class="citation" data-cites="JanValiska">@JanValiska</span>, <span
class="citation" data-cites="KarlK90">@KarlK90</span>, <span
class="citation" data-cites="jasonkena">@jasonkena</span>, <span
class="citation" data-cites="jdart">@jdart</span>, <span
class="citation" data-cites="jweickm">@jweickm</span>, <span
class="citation" data-cites="MichaelOstermann">@MichaelOstermann</span>,
<span class="citation" data-cites="proostas">@proostas</span>, <span
class="citation" data-cites="SavageMessiah">@SavageMessiah</span>, <span
class="citation" data-cites="Sigvah">@Sigvah</span>, <span
class="citation" data-cites="sommerper">@sommerper</span>, <span
class="citation" data-cites="TristanCacqueray">@TristanCacqueray</span>
and Reddit user u/02ranger for contributions and feedback to improve
Achordion and Chordal Hold.</p>
<p><a href="../index.html">‚Üê More about keyboards</a></p>
</div>

<div id="footer">
<p style="text-align:right">
<a href="https://scholar.google.com/citations?user=G8Yjd9AAAAAJ" target="_blank">Google Scholar</a>
<a href="http://www.linkedin.com/in/pascalgetreuer" target="_blank">LinkedIn</a>
</p>
</div>
</body>
</html>
