<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="author" content="Pascal Getreuer" />
  <title>QMK triggers: reacting to interesting events</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<link rel="stylesheet" href="../../../site.css" type="text/css" />
<link rel="icon" href="../../../favicon.ico" type="image/x-icon" />
<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC" rel="stylesheet" />
<script type="text/javascript" src="../../../site.js" ></script>
</head>
<body>
<div id="navbar">
<div id="navhold">
  <a href="../../../index.html">Home</a>
  <a href="../../../papers/index.html">Papers</a>
  <a href="../../../posts/index.html">Posts</a>
</div>
</div>
<div id="content">
<div id="header">
<h1 class="title">QMK triggers: reacting to interesting events</h1>
<h2 class="author">Pascal Getreuer</h2>
</div>
<div id="TOC">
<ul>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#license">License</a></li>
</ul></li>
<li><a href="#on-entering-or-exiting-a-layer">On entering or exiting a layer</a></li>
<li><a href="#tap-vs.-long-press">Tap vs. long press</a></li>
<li><a href="#when-mod-combo-is-held">When mod combo is held</a></li>
<li><a href="#action-on-double-tap-without-delay">Action on double tap, without delay</a></li>
<li><a href="#when-another-key-is-held">When another key is held</a></li>
<li><a href="#based-on-previously-typed-keys">Based on previously typed keys</a></li>
<li><a href="#closing-thoughts">Closing thoughts</a></li>
</ul>
</div>
<p><a href="../index.html">← More about keyboards</a></p>
<h2 id="overview">Overview</h2>
<p>We will discuss how to implement different kinds of triggers for an action in QMK. By “triggers,” I mean reacting to events like that a button was double tapped or a layer became active. I assume here you are familiar with things like handling a custom keycode in <code>process_record_user()</code>; if not, check out <a href="../macros/index.html">my QMK macros post</a> first. As covered in that post, a lot of useful effects are possible with a button that performs a custom action. Triggers enable yet more beyond that.</p>
<h3 id="license">License</h3>
<p>Code snippets in this post are shared under Apache 2 license.</p>
<div style="font-size:85%">
<blockquote>
<p>Copyright 2022 Google LLC</p>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="https://www.apache.org/licenses/LICENSE-2.0" class="uri">https://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
</blockquote>
</div>
<h2 id="on-entering-or-exiting-a-layer">On entering or exiting a layer</h2>
<p>The <code>layer_state_set_user()</code> callback is called every time the layer state changes. Within this callback, use <code>get_highest_layer(state)</code> to get the index of the highest active layer or <code>IS_LAYER_ON_STATE(state, layer)</code> to check whether <code>layer</code> is on.</p>
<p>Implement an LED layer indicator by adding something like this in keymap.c:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>layer_state_t layer_state_set_user(layer_state_t state) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  writePin(B0, get_highest_layer(state) &gt; <span class="dv">0</span>);</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="cf">return</span> state;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Change <code>B0</code> to the pin for the LED to use. The above assumes setting the pin high turns the LED on—if that’s flipped, negate the logic on the second arg.</p>
<p>Note that <code>layer_state_set_user()</code> is called on every layer state change. To react only when entering or exiting a specific <code>ADJUST</code> layer, use a pattern like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>layer_state_t layer_state_set_user(layer_state_t state) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="co">// Use `static` variable to remember the previous status.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="dt">static</span> <span class="dt">bool</span> adjust_on = false;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="cf">if</span> (adjust_on != IS_LAYER_ON_STATE(state, ADJUST)) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    adjust_on = !adjust_on;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    <span class="cf">if</span> (adjust_on) {  <span class="co">// Just entered the ADJUST layer.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>      PLAY_SONG(MAJOR_SONG);</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    } <span class="cf">else</span> {          <span class="co">// Just exited the ADJUST layer.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>      PLAY_SONG(GOODBYE_SONG);</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    }</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  }</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>  <span class="cf">return</span> state;</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>See also the QMK documentation on <a href="https://docs.qmk.fm/#/custom_quantum_functions?id=layer-change-code">Layer Change Code</a> and <a href="https://docs.qmk.fm/#/feature_led_indicators">LED Indicators</a>.</p>
<h2 id="tap-vs.-long-press">Tap vs. long press</h2>
<p>Taking inspiration from <a href="https://docs.qmk.fm/#/feature_auto_shift">Auto Shift</a>, we can have a key perform different actions on a regular tap vs. holding the key a bit longer. While a similar effect could be done with <a href="https://docs.qmk.fm/#/feature_tap_dance">a tap dance</a>, a better way to do it is to customize a layer-tap <code>LT</code> key. Thanks to <span class="citation" data-cites="filterpaper">@filterpaper</span> and <span class="citation" data-cites="jweickm">@jweickm</span> for teaching me this trick.</p>
<p>Compared to tap dance, customizing an <code>LT</code> gets the tap-hold decision logic for free, which is more finely configurable to avoid accidental fires on rolled presses and so on. Once you have seen the pattern, it’s also arguably simpler to write.</p>
<p>First, define a layer-tap key like <code>LT(0, kc)</code>, where <code>kc</code> is a basic keycode to be sent on tap and the layer is a dummy placeholder.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="pp">#define COMM_COPY LT(0, KC_COMM)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="pp">#define DOT_PASTE LT(0, KC_DOT)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="pp">#define MPLY_MNXT LT(0, KC_MPLY)</span></span></code></pre></div>
<p>Then in <code>process_record_user()</code>, we customize the long press action:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">// Helper for implementing tap vs. long-press keys. Given a tap-hold</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">// key event, replaces the hold function with `long_press_keycode`.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="dt">static</span> <span class="dt">bool</span> process_tap_or_long_press_key(</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    keyrecord_t* record, <span class="dt">uint16_t</span> long_press_keycode) {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="cf">if</span> (record-&gt;tap.count == <span class="dv">0</span>) {  <span class="co">// Key is being held.</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="cf">if</span> (record-&gt;event.pressed) {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>      register_code16(long_press_keycode);</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>      unregister_code16(long_press_keycode);</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    }</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="cf">return</span> false;  <span class="co">// Skip default handling.</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  }</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  <span class="cf">return</span> true;  <span class="co">// Continue default handling.</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>}</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="dt">bool</span> process_record_user(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  <span class="cf">switch</span> (keycode) {</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    <span class="cf">case</span> COMM_COPY:  <span class="co">// Comma on tap, Ctrl+C on long press.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>      <span class="cf">return</span> process_tap_or_long_press_key(record, C(KC_C));</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>    <span class="cf">case</span> DOT_PASTE:  <span class="co">// Paste on tap, Ctrl+V on long press.</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>      <span class="cf">return</span> process_tap_or_long_press_key(record, C(KC_V));</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>    <span class="cf">case</span> MPLY_MNXT:  <span class="co">// Play/pause on tap, next song on long press.</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>      <span class="cf">return</span> process_tap_or_long_press_key(record, KC_MNXT);</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>    <span class="co">// Other macros...</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>  }</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a>  <span class="cf">return</span> true;</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a>}</span></code></pre></div>
<p>See also <a href="https://docs.qmk.fm/#/mod_tap?id=changing-hold-function">changing the hold function</a> in the mod-tap documentation. The above requires that the tap action is a <a href="https://docs.qmk.fm/#/keycodes_basic">basic keycode</a>, a limitation due to how tap-hold keys are represented. If you need an advanced keycode or will execute custom code for the tap action, this is possible by <a href="https://docs.qmk.fm/#/mod_tap?id=changing-tap-function">changing the tap function</a> as well. Start by defining a layer-tap key in which both the mod and tap keycode are placeholders.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="pp">#define FANCY_KEY  LT(0, KC_1)</span></span></code></pre></div>
<p>If you define multiple such keys with this approach, use different tap keycodes (say, <code>KC_1</code>, <code>KC_2</code>, <code>KC_3</code>, …) to make them distinct.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="cf">case</span> FANCY_KEY:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="cf">if</span> (record-&gt;tap.count &gt; <span class="dv">0</span>) {    <span class="co">// Key is being tapped.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="cf">if</span> (record-&gt;event.pressed) {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>      <span class="co">// Handle tap press event...</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>      <span class="co">// Handle tap release event...</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    }</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  } <span class="cf">else</span> {                        <span class="co">// Key is being held.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="cf">if</span> (record-&gt;event.pressed) {</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>      <span class="co">// Handle hold press event...</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>      <span class="co">// Handle hold release event...</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    }</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>  }</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>  <span class="cf">return</span> false;  <span class="co">// Skip default handling.</span></span></code></pre></div>
<h2 id="when-mod-combo-is-held">When mod combo is held</h2>
<p>You can use pressing Left Shift and Right Shift at the same time as a way to trigger an action, like I did for <a href="../caps-word/index.html">Caps Word</a>. The below method works with the normal Shift keys (<code>KC_LSFT</code>, <code>KC_RSFT</code>) as well as one-shot Shift mods and Space Cadet Shift. The action can also be triggered using mod-tap Shift keys by holding both Shift mod-tap keys until the tapping term, then release them.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">const</span> <span class="dt">uint8_t</span> mods = get_mods() | get_oneshot_mods();</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="cf">if</span> (mods == MOD_MASK_SHIFT) {  <span class="co">// Left Shift + Right Shift held.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  clear_mods();  <span class="co">// If needed, clear the mods.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="co">// Do something interesting...</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Keep in mind that Shift is active when triggered, so call <code>clear_mods()</code> first if needed before performing the action. You could similarly trigger an action when both Ctrl keys are held by changing <code>MOD_MASK_SHIFT</code> to <code>MOD_MASK_CTRL</code> or even use a mix like Left Alt + Right GUI with <code>(MOD_BIT(KC_LEFT_ALT) | MOD_BIT(KC_RIGHT_GUI))</code>.</p>
<p>See also <a href="https://docs.qmk.fm/#/feature_advanced_keycodes?id=checking-modifier-state">Checking Modifier State</a>.</p>
<p><strong>Note about Command:</strong> The <a href="https://docs.qmk.fm/#/feature_command">Command feature</a> also uses the Left Shift + Right Shift mod combination. To avoid conflict, disable Command by adding in rules.mk:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode mk"><code class="sourceCode makefile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="dt">COMMAND_ENABLE </span><span class="ch">=</span><span class="st"> no</span></span></code></pre></div>
<p>Or set it to use a different mod combination by defining <code>IS_COMMAND()</code> in config.h:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// Activate Command with Left Ctrl + Right Ctrl.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="pp">#define IS_COMMAND() (get_mods() == MOD_MASK_CTRL)</span></span></code></pre></div>
<h2 id="action-on-double-tap-without-delay">Action on double tap, without delay</h2>
<p>Suppose you want to perform some action when a Shift or Ctrl key is double tapped, <strong>yet otherwise have the key act as usual without any delays</strong>. This could again be done with a tap dance, but here is a short code snippet to do it directly.</p>
<p>With this implementation, the Shift key continues to function as usual even as it is double tapped. This is essential in making Shift act without delay. Otherwise when Shift is pressed, we would have to wait out <code>TAPPING_TERM</code> to see whether it gets tapped again before sending keys to the host.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="cf">if</span> (record-&gt;event.pressed) {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="dt">static</span> <span class="dt">bool</span> tapped = false;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  <span class="dt">static</span> <span class="dt">uint16_t</span> tap_timer = <span class="dv">0</span>;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  <span class="cf">if</span> (keycode == KC_LSFT) {</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span class="cf">if</span> (tapped &amp;&amp; !timer_expired(record-&gt;event.time, tap_timer)) {</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>      <span class="co">// The key was double tapped.</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>      clear_mods();  <span class="co">// If needed, clear the mods.</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>      <span class="co">// Do something interesting...</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    }</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    tapped = true;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    tap_timer = record-&gt;event.time + TAPPING_TERM;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>  } <span class="cf">else</span> {</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>    <span class="co">// On an event with any other key, reset the double tap state.</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>    tapped = false;</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>  }</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>When <code>KC_LSFT</code> is pressed, we use a <a href="https://docs.qmk.fm/#/ref_functions?id=software-timers">software timer</a> to check whether it was recently tapped. If so, this is a double tap (or possibly a triple tap or more). Two taps are considered a double tap if the presses are within <code>TAPPING_TERM</code> (200 ms by default).</p>
<p>For <a href="../mouse-turbo-click/index.html">Mouse Turbo Click</a>, I used double tapping to lock Turbo Click. Its implementation follows the code above.</p>
<h2 id="when-another-key-is-held">When another key is held</h2>
<p>Besides held modifiers, an action can be conditionally triggered based on another key being held.</p>
<p>For instance with the following, the J and K keys become PgDn and PgUp while Backspace is held. The Backspace key continues to function as usual without any added delay, making it an interesting alternative to combos and layer-tap keys.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="dt">bool</span> process_record_user(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="dt">static</span> <span class="dt">bool</span> bspc_is_held = false;</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  <span class="cf">switch</span> (keycode) {</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    <span class="cf">case</span> KC_BSPC:</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>      bspc_is_held = record-&gt;event.pressed;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>      <span class="cf">break</span>;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    <span class="cf">case</span> KC_J: {  <span class="co">// Backspace + J = PgDn.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>      <span class="dt">static</span> <span class="dt">uint8_t</span> registered_key = KC_NO;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>      <span class="cf">if</span> (record-&gt;event.pressed) {</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>        registered_key = (bspc_is_held) ? KC_PGDN : KC_J;</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>        register_code(registered_key);</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>      } <span class="cf">else</span> {</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>        unregister_code(registered_key);</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>      }</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>    } <span class="cf">return</span> false;</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>    <span class="cf">case</span> KC_K: {  <span class="co">// Backspace + K = PgUp.</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>      <span class="dt">static</span> <span class="dt">uint8_t</span> registered_key = KC_NO;</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>      <span class="cf">if</span> (record-&gt;event.pressed) {</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a>        registered_key = (bspc_is_held) ? KC_PGUP : KC_K;</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a>        register_code(registered_key);</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a>      } <span class="cf">else</span> {</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true"></a>        unregister_code(registered_key);</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true"></a>      }</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true"></a>    } <span class="cf">return</span> false;</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true"></a>  }</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true"></a></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true"></a>  <span class="cf">return</span> true;</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true"></a>} </span></code></pre></div>
<h2 id="based-on-previously-typed-keys">Based on previously typed keys</h2>
<p>Some effects depend on previously typed keys. For example, an alternative to <a href="https://docs.qmk.fm/#/feature_leader_key">Leader Key</a>: when a special pattern “<code>qem</code>” is typed, automatically send backspaces to remove it followed by keys to type your email address. Or as I did in <a href="../autocorrection/index.html">Autocorrection</a>, when a typo is typed, automatically send keys to correct it.</p>
<p>There are some technicalities in identifying “typed” keys properly:</p>
<ol type="1">
<li><p>Not all key presses type text. For instance, pressing the Left Shift key (<code>KC_LSFT</code>) generates a press event, but it does not on its own type text. Similarly, a mod-tap or layer-tap key types no text when it is held, but it might when it is tapped.</p></li>
<li><p>Navigation keys (like arrows) and keys pressed with mods other than shift (hotkeys like Ctrl+W) may move the cursor or change the application state. When this happens, it is best to forget whatever keys had been typed up to that point.</p></li>
<li><p>Similarly, the mouse may move the cursor or change application state. Unfortunately, unless the user uses <a href="https://docs.qmk.fm/#/feature_mouse_keys">Mouse Keys</a>, there is no practical way for QMK to know what the mouse does.</p></li>
</ol>
<p>For the first two points, we can check the <code>keycode</code> for what kind of key it is and <code>get_mods()</code> for non-shift modifiers. For the third point, a mitigation is to use a timer: if no keys are typed within <code>TIMEOUT_MS</code>, the buffer of typed keys is cleared.</p>
<p>The following implements a sliding buffer of the last 8 typed keys.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span><span class="pp"> </span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="pp">#define TIMEOUT_MS 5000  </span><span class="co">// Timeout in milliseconds.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="pp">#define RECENT_SIZE 8    </span><span class="co">// Number of keys in `recent` buffer.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="dt">static</span> <span class="dt">uint16_t</span> recent[RECENT_SIZE] = {KC_NO};</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="dt">static</span> <span class="dt">uint16_t</span> deadline = <span class="dv">0</span>;</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a><span class="dt">static</span> <span class="dt">void</span> clear_recent_keys(<span class="dt">void</span>) {</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  memset(recent, <span class="dv">0</span>, <span class="kw">sizeof</span>(recent));  <span class="co">// Set all zeros (KC_NO).</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>}</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span class="co">// Handles one event. Returns true if the key was appended to `recent`.</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a><span class="dt">static</span> <span class="dt">bool</span> update_recent_keys(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>  <span class="cf">if</span> (!record-&gt;event.pressed) { <span class="cf">return</span> false; }</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>  <span class="cf">if</span> (((get_mods() | get_oneshot_mods()) &amp; ~MOD_MASK_SHIFT) != <span class="dv">0</span>) {</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>    clear_recent_keys();  <span class="co">// Avoid interfering with hotkeys.</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>    <span class="cf">return</span> false;</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>  }</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>  <span class="co">// Handle tap-hold keys.</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>  <span class="cf">switch</span> (keycode) {</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>    <span class="cf">case</span> QK_MOD_TAP ... QK_MOD_TAP_MAX:</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>    <span class="cf">case</span> QK_LAYER_TAP ... QK_LAYER_TAP_MAX:</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>      <span class="cf">if</span> (record-&gt;tap.count == <span class="dv">0</span>) { <span class="cf">return</span> false; }</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a>      keycode &amp;= <span class="bn">0xff</span>;  <span class="co">// Get tapping keycode.</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a>  }</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a>  <span class="cf">switch</span> (keycode) {</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>    <span class="cf">case</span> KC_A ... KC_SLASH:  <span class="co">// These keys type letters, digits, symbols.</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>      <span class="cf">break</span>;</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>    <span class="cf">case</span> KC_LSFT:  <span class="co">// These keys don&#39;t type anything on their own.</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a>    <span class="cf">case</span> KC_RSFT:</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a>    <span class="cf">case</span> QK_ONE_SHOT_MOD ... QK_ONE_SHOT_MOD_MAX:</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a>      <span class="cf">return</span> false;</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>    <span class="cf">default</span>:  <span class="co">// Avoid acting otherwise, particularly on navigation keys.</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a>      clear_recent_keys();</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true"></a>      <span class="cf">return</span> false;</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true"></a>  }</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true"></a>    </span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true"></a>  <span class="co">// Slide the buffer left by one element.</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true"></a>  memmove(recent, recent + <span class="dv">1</span>, (RECENT_SIZE - <span class="dv">1</span>) * <span class="kw">sizeof</span>(*recent));</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true"></a></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true"></a>  recent[RECENT_SIZE - <span class="dv">1</span>] = keycode;</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true"></a>  deadline = record-&gt;event.time + TIMEOUT_MS;</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true"></a>  <span class="cf">return</span> true;</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true"></a>}</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true"></a></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true"></a><span class="dt">void</span> matrix_scan_user(<span class="dt">void</span>) {</span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true"></a>  <span class="cf">if</span> (recent[RECENT_SIZE - <span class="dv">1</span>] &amp;&amp; timer_expired(timer_read(), deadline)) {</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true"></a>    clear_recent_keys();  <span class="co">// Timed out; clear the buffer.</span></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true"></a>  }</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true"></a>}</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true"></a></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true"></a><span class="dt">bool</span> process_record_user(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true"></a>  <span class="cf">if</span> (update_recent_keys(keycode, record)) {</span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true"></a>    <span class="co">// Continued below...</span></span></code></pre></div>
<p>On each event, <code>update_recent_keys()</code> is called to add the key to the buffer.</p>
<p>The code above is long as it is, yet there is more that can be done in the key handling logic such as ignoring layer switch keys, handling shifted keycodes, and implementing Backspace to remove the last key from the buffer. See the <a href="https://github.com/getreuer/qmk-keymap/blob/main/features/autocorrection.c">Autocorrection source code</a> for a thorough implementation. For the buffer itself, there are of course other ways it could be done. Particularly, while general keycodes are <code>uint16_t</code> values, you could choose to store them as <code>uint8_t</code> if the logic that follows is limited to basic keycodes.</p>
<p>From there, we can implement the “<code>qem</code>” email address example described above:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="dt">bool</span> process_record_user(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="cf">if</span> (update_recent_keys(keycode, record)) {</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="co">// Expand &quot;qem&quot; to my email address.</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="cf">if</span> (recent[RECENT_SIZE - <span class="dv">3</span>] == KC_Q &amp;&amp;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>        recent[RECENT_SIZE - <span class="dv">2</span>] == KC_E &amp;&amp;</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        recent[RECENT_SIZE - <span class="dv">1</span>] == KC_M) {</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>      SEND_STRING(SS_TAP(X_BSPC) SS_TAP(X_BSPC) <span class="st">&quot;myname@email.com&quot;</span>);</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>      <span class="cf">return</span> false;</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>    }</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>    <span class="co">// Expand &quot;qph&quot; to my phone number.</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    <span class="cf">if</span> (recent[RECENT_SIZE - <span class="dv">3</span>] == KC_Q &amp;&amp;</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>        recent[RECENT_SIZE - <span class="dv">2</span>] == KC_P &amp;&amp;</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>        recent[RECENT_SIZE - <span class="dv">1</span>] == KC_H) {</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>      SEND_STRING(SS_TAP(X_BSPC) SS_TAP(X_BSPC) <span class="st">&quot;123-546-7890&quot;</span>);</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>      <span class="cf">return</span> false;</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>    }</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>  }</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>  <span class="cf">return</span> true;</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>}</span></code></pre></div>
<p>Another application is “adaptive keys” to type common bigrams more comfortably. For example (assuming QWERTY layout) an adaptive U key where typing <code>iu</code> produces <code>in</code>. For this use, I would set <code>TIMEOUT_MS</code> to something rather low like 250 ms so that only quick typing triggers it.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="dt">bool</span> process_record_user(<span class="dt">uint16_t</span> keycode, keyrecord_t* record) {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  <span class="cf">if</span> (update_recent_keys(keycode, record)) {</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="cf">if</span> (recent[RECENT_SIZE - <span class="dv">2</span>] == KC_I &amp;&amp;</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>        recent[RECENT_SIZE - <span class="dv">1</span>] == KC_U) {</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>      tap_code(KC_N);  <span class="co">// Type &#39;n&#39; instead of &#39;u&#39;.</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>      <span class="cf">return</span> false;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    }</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>  }</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>  <span class="cf">return</span> true;</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>}</span></code></pre></div>
<p>If you are testing the <code>recent</code> buffer for a dozen or so patterns, it is reasonable to do it as above, checking for one after another. However, for a larger number of patterns, more elaborate data structures and algorithms may be a win. Autocorrection <a href="../autocorrection/index.html#how-does-it-work">uses a trie data structure</a> to efficiently test for possibly hundreds to low thousands of typos.</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>There are a variety of ways to trigger an action in QMK, enabling a range of interesting effects. I’m excited in particular about actions based on previously typed keys. Knowing what <em>word</em> was just typed, not just the last key, opens new possibilities.</p>
<p><a href="../index.html">← More about keyboards</a></p>
</div>

<div id="footer">
<p style="text-align:right">
<a href="https://scholar.google.com/citations?user=G8Yjd9AAAAAJ" target="_blank">Google Scholar</a>
<a href="http://www.linkedin.com/in/pascalgetreuer" target="_blank">LinkedIn</a>
</p>
</div>
</body>
</html>
